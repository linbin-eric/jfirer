<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://eric_ds.gitee.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="ConcurrentHashMap源码走读[TOC] 简介在从JDK8开始，为了提高并发度，ConcurrentHashMap的源码进行了很大的调整。在JDK7中，采用的是分段锁的思路。简单的说，就是ConcurrentHashMap是由多个HashMap构成。当需要进行写入操作的时候，会寻找到对应的HashMap，使用synchronized对对应的hashmap加锁，然后执行写入操作。显然，并">
<meta property="og:type" content="article">
<meta property="og:title" content="ConcurrentHashMap源码走读">
<meta property="og:url" content="https://eric_ds.gitee.io/2019/11/04/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/index.html">
<meta property="og:site_name" content="风火说">
<meta property="og:description" content="ConcurrentHashMap源码走读[TOC] 简介在从JDK8开始，为了提高并发度，ConcurrentHashMap的源码进行了很大的调整。在JDK7中，采用的是分段锁的思路。简单的说，就是ConcurrentHashMap是由多个HashMap构成。当需要进行写入操作的时候，会寻找到对应的HashMap，使用synchronized对对应的hashmap加锁，然后执行写入操作。显然，并">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191029144409.png">
<meta property="article:published_time" content="2019-11-04T00:00:00.000Z">
<meta property="article:modified_time" content="2020-02-07T06:58:55.934Z">
<meta property="article:author" content="风火">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191029144409.png">

<link rel="canonical" href="https://eric_ds.gitee.io/2019/11/04/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>ConcurrentHashMap源码走读 | 风火说</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风火说</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eric_ds.gitee.io/2019/11/04/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200207124809.jpg">
      <meta itemprop="name" content="风火">
      <meta itemprop="description" content="博思软件技术架构部技术经理，福建省省级标准《双离线场景二维码标准》撰写人，多年大型项目研发经验。GitChat认证作者，关注团队效率，高并发等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风火说">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ConcurrentHashMap源码走读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-04 08:00:00" itemprop="dateCreated datePublished" datetime="2019-11-04T08:00:00+08:00">2019-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-07 14:58:55" itemprop="dateModified" datetime="2020-02-07T14:58:55+08:00">2020-02-07</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="ConcurrentHashMap源码走读"><a href="#ConcurrentHashMap源码走读" class="headerlink" title="ConcurrentHashMap源码走读"></a>ConcurrentHashMap源码走读</h1><p>[TOC]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在从JDK8开始，为了提高并发度，<code>ConcurrentHashMap</code>的源码进行了很大的调整。在JDK7中，采用的是分段锁的思路。简单的说，就是<code>ConcurrentHashMap</code>是由多个<code>HashMap</code>构成。当需要进行写入操作的时候，会寻找到对应的<code>HashMap</code>，使用<code>synchronized</code>对对应的<code>hashmap</code>加锁，然后执行写入操作。显然，并发程度就取决于<code>HashMap</code>个数的多少。而在JDK8中换了一种完全不同的思路。</p>
<p>首先，仍然是使用<code>Entry[]</code>作为数据的基本存储。但是锁的粒度被缩小到了数组中的每一个槽位上，数据读取的可见性依靠<code>volatile</code>来保证。而在尝试写入的时候，会将对应的槽位上的元素作为加锁对象，使用<code>synchronized</code>进行加锁，来保证并发写入的安全性。</p>
<p>除此之外，如果多个Key的<code>hashcode</code>在取模后落在了相同的槽位上，在一定数量内（默认是8），采用链表的方式连接节点；超过之后，为了提高查询效率，会将槽位上的节点转为使用红黑树结构进行存储。</p>
<p>还有一个比较大的改变在于当进行扩容的时候，除了扩容线程本身，如果其他线程识别到了扩容进行中，则会尝试协助扩容。</p>
<p>下面来看下来针对几个重点方法进行源码分析。</p>
<p>欢迎加入技术交流群186233599讨论交流，也欢迎关注技术公众号：风火说。</p>
<a id="more"></a>

<h2 id="放入数据"><a href="#放入数据" class="headerlink" title="放入数据"></a>放入数据</h2><p>添加数据的方法为<code>java.util.concurrent.ConcurrentHashMap#put</code>，该内容实现委托给方法<code>java.util.concurrent.ConcurrentHashMap#putVal</code>。</p>
<p>该方法整体上可以为分为三个部分：</p>
<ul>
<li>使用<code>spread</code>方法得到key的hashcode</li>
<li>将KV对在<code>Entry[]</code>寻找合适的位置放入</li>
<li>容器内元素总数+1，并且在需要时执行扩容。</li>
</ul>
<p>第一步没什么好说的，直接来看第二步的相关代码，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();<span class="comment">//初始化数组，标记1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;   <span class="comment">//标记2           </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f); <span class="comment">//标记3</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">//省略相关代码，标记4</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i); <span class="comment">//标记5</span></span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>代码比较复杂，我们分成了5个标记进行说明。</p>
<p>首先是<strong>标记1</strong>，如果尝试添加元素时发现<code>table</code>属性为null，则意味着整个容器尚未初始化，此时执行初始化方法，也就是<code>initTable</code>，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>整体思路很明确，通过CAS争夺<code>sizeCtl</code>属性的控制权，成功将该值设置为-1的线程可以执行初始化工作，而其他线程通过<code>Thread.yield()</code>进行等待，直到确认容器初始化完毕，也就是<code>table</code>属性有了值。当初始化完毕时，<code>sizeCtl</code>会被设置为下一次扩容的容量阀值，该值为当前容量的3/4。</p>
<p>如果容器已经初始化，并且Key的hashcode对应的槽位为空，则可以考虑新建一个节点放入该槽位。也就是<strong>标记2</strong>。这里解释下槽位上数据的读取，都是通过方法<code>tabAt</code>，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该取值方法是通过计算对应槽位在数组中的便宜量的值，即<code>((long)i &lt;&lt; ASHIFT) + ABASE</code>，也就是基础偏移量+元素间隔偏移量。并且读取的时候使用的是<code>getObjectVolatile</code>，该方法的读取和对属性使用<code>volatile</code>是一样的效果，可以保证读取到最新的值。</p>
<p>接着来看标记2，在槽位为null的情况下，其对值的写入采用了CAS方式，也是为了保证并发的安全性。如果CAS成功，则元素添加完毕，可以直接退出循环。如果CAS失败，则意味着有其他线程已经对相同的槽位操作成功，此时就要重新循环，确认最新的情况。</p>
<p>如果对应的槽位不为空，且其hashcode标识为特定负数，也就是标识容器正在扩容的负数，此时需要协助进行容器扩容，也就是<strong>标记3</strong>。</p>
<p>这里对Key的hashcode做一个说明，由于key的hashcode会经过方法<code>spread</code>处理，因此必然为正数。而负数的hashcode有三个特殊的含义，分别是:</p>
<ul>
<li>-1：代表容器在扩容，并且当前节点的数据已经前移到扩容后的数组中。</li>
<li>-2：代表当前槽位上的节点采用红黑树结构存储。</li>
<li>-3：代表该节点正在进行函数式运算，节点值还未最终确定。</li>
</ul>
<p>协助扩容的分析与容器扩容放在一起，这边先暂时略过。</p>
<p>如果对应槽位不为空，且hashcode不为负数，就意味着该槽位可以执行元素添加，也就是<strong>标记4</strong>。来看下对应的代码，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//省略相关代码，其内容为在链表上添加元素，将元素添加到队列的末尾</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           <span class="comment">//省略相关代码，其内容为在红黑树结构上添加元素</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>为了保证对同一个槽位上并发更新的安全性，需要对槽位上的节点执行加锁操作。</p>
<p>取得锁之后，首先确认当前槽位上的节点是否仍然是加锁成功的节点，一致的情况说明加锁成功的前后，槽位上数据形式没有变动，才能执行后续的操作。</p>
<p>加锁完毕后，判断槽位上节点的类型，如果hashcode大于等于0，是为普通节点，意味着该槽位上的数据采样链表形式存储，否则判断节点类型（必然为红黑树节点，也就是TreeBin），确认其为红黑树节点。</p>
<p>普通节点的添加很简单，通过对比节点中的key和Value是否和要添加的KV对一致来判断是否重复，没有重复的情况下就添加到队尾。重复的情况下则依据方法入参<code>onlyIfAbsent</code>的值判断是否要进行替换。</p>
<p>红黑树节点的添加则比较复杂，具体算法可以参看红黑树，这边不再赘述。</p>
<p>当元素添加成功后，如果当前槽位采用链表存储节点，并且链表长度超过阀值，则将链表转化为红黑树结构。也就是<strong>标记5</strong>。</p>
<p>数据放入完毕后，就是对容器内元素个数的总数进行增加操作了，也就是第三步的内容。</p>
<h2 id="容器元素总数更新"><a href="#容器元素总数更新" class="headerlink" title="容器元素总数更新"></a>容器元素总数更新</h2><p>元素总数更新是依靠方法<code>addCount</code>完成。该方法总体分为两个步骤：</p>
<ul>
<li>总数更新</li>
<li>根据入参和当前总数，判断是否执行扩容。</li>
</ul>
<p>首先来看总数更新的部分，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>整体的更新思路实际上和JDK8新增的一个统计类是完全一致的，即<code>java.util.concurrent.atomic.LongAdder</code>。这个类用于在更高的并发竞争下，降低或维持数字计算的延迟。其性能相较传统的<code>AtomicLong</code>要更好。具体的代码分析这边就不展开了，但是说下核心思路：</p>
<ul>
<li>整个统计的数据结构包含一个基本的长整形变量baseCount和一个统计单元CounterCell构成的数组，数组的长度为2的次方幂，初始长度为2，最大长度超过CPU内核数时停止扩容。</li>
<li>当统计数字需要变化时，优先在baseCount上执行CAS操作。如果CAS成功，则意味着更新完成。如果失败，说明此时有多线程竞争，放弃在<code>baseCount</code>上的争夺。</li>
<li>当放弃在<code>baseCount</code>上的争夺时，通过线程上的随机数h在<code>CounterCell[]</code>数组上找到槽位，在槽位上的<code>CounterCell</code>内部的整型变量上循环执行CAS更新，直到成功。</li>
<li>如果需要初始化<code>CounterCell[]</code>数组或者添加元素到具体槽位，或者库容，只能一个线程进行，该线程需要对<code>cellBusy</code>这个属性进行CAS争夺并且成功。</li>
</ul>
<p>这个算法的核心思路就是避免多线程在一个变量上循环CAS直到成功。因为当多线程竞争较为激烈时，大量的线程会在不断的CAS失败中浪费很多CPU时间。通过线程变量的方法，将多线程分散到不同的<code>CounterCell</code>单元中，降低了竞争的烈度和颗粒度，因此能够提高并发效率。</p>
<p>由于统计数据被分散在<code>baseCount</code>和<code>CounterCell[]</code>中，执行总数计算时也需要遍历这里面所有的值相加才能得到最终值。</p>
<p>总数更新完毕后，就到了扩容判断环节了。</p>
<h2 id="容器扩容"><a href="#容器扩容" class="headerlink" title="容器扩容"></a>容器扩容</h2><p>容器扩容判断是在总数更新中的部分代码实现的，具体如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);<span class="comment">//标记1</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;<span class="comment">//标记2</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))<span class="comment">//标记3</span></span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，扩容的依据是<code>sizeCtl</code>这个属性，当容器元素总数超过<code>sizeCtl</code>时，执行扩容流程。</p>
<p>首先第一步<strong>标记1</strong>，是对容器内当前数组长度计算盖戳标记值，也就是<code>resizeStamp</code>，其具体代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由于n是2的次方幂，<code>Integer.numberOfLeadingZeros(n)</code>是获得32位整型数字中，在第一个1的位之前有多少个0的结果，因此这个值实际上就是数字n的一种换算关系。</p>
<p><code>RESIZE_STAMP_BITS</code>则意味着该结果能够占据的比特位数。由于<code>Integer.numberOfLeadingZeros(n)</code>最大值为28（n的最小值为16），因此<code>RESIZE_STAMP_BITS</code>最小也必须为6。</p>
<p>这个方法计算出来的结果，实际上可以看成是数组的长度的固定换算值。这个值可以在多线程扩容过程用于判断是否扩容完毕了。</p>
<p>这里要对<code>sizeCtl</code>这个属性做一下说明，其取值有如下规律：</p>
<ul>
<li>0：这是一个初始值，意味着此时数组尚未初始化。</li>
<li>-1：这是一个控制值，意味着有线程取得了数组的初始化权利，并且正在执行初始化中。</li>
<li>正数：该值是容器要扩容的阀值，一旦元素总数到达该值，则应该进行扩容。除非数组长度到达上限。</li>
<li>非-1的负数：该值意味着当前数组正在扩容，该值的左边<code>RESIZE_STAMP_BITS</code>个数的比特位用于存储数组长度n的盖戳标记，右边<code>32-RESIZE_STAMP_BITS</code>位用于存储当前参与扩容的线程数。</li>
</ul>
<p>回到扩容的代码，标记1代码完成后，就开始判断是执行扩容还是协助扩容。如果<code>sizeCtl</code>当前值为负数，就协助扩容也就是<strong>标记2</strong>；如果为正数，就发起扩容，也就是<strong>标记3</strong>。</p>
<p>首先来看标记3，也就是发起扩容。需要通过CAS对<code>sizeCtl</code>的值进行置换。发起扩容时需要置换的值的含义上面也说过，左边是盖戳标记，右边是参与扩容的线程数。</p>
<p>来看下扩容的具体代码，也就是<code>transfer</code>方法，该方法较为复杂，具体区分为几个步骤：</p>
<ul>
<li>步骤一：计算当前线程本次前移的槽位个数</li>
<li>步骤二：初始化扩容后的数组对象，赋值给属性<code>nextTable</code></li>
<li>步骤三：按照步骤一计算的结果，从数组的末尾开始，每批迁移一定槽位上的节点到新的数组直到全部迁移完毕；将新的数组的值赋值给属性<code>table</code>，将属性<code>nextTable</code>设置为null，计算新的<code>sizeCtl</code>，迁移完成。</li>
</ul>
<p>首先来看步骤一，很简单，只有一句代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE;</span><br></pre></td></tr></table></figure>

<p>默认情况下，每次迁移1/8的槽位。</p>
<p>步骤二一样也很简单，就是一个基本的赋值动作，就不展开了。</p>
<p>步骤三比较复杂，在细分为几个阶段：</p>
<ul>
<li>阶段一：计算本次迁移开始的槽位下标和数量。</li>
<li>阶段二：判断迁移是否完成，如果完成则设置相关属性。</li>
<li>阶段三：按照阶段一的槽位下标和数量，执行迁移。</li>
</ul>
<p>先来看阶段一，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> finishing = <span class="keyword">false</span>;</span><br><span class="line">ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">        <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,nextBound = (nextIndex &gt; stride ?nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">            bound = nextBound;</span><br><span class="line">            i = nextIndex - <span class="number">1</span>;</span><br><span class="line">            advance = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//阶段二代码</span></span><br><span class="line">         <span class="comment">//阶段三代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>transferIndex</code>的初值为数组的长度。确定本次前移的槽位范围是第二个else if来决定的。通过CAS争夺，将<code>transferIndex</code>的值降低。CAS成功后，本次减少的<code>transferIndex</code>值对应的区域，就是本次迁移的区域。通过这种方式，每个线程都可以在自己独立的槽位范围内作业而不会互相争夺，避免竞争。</p>
<p>阶段二用于判断迁移是否完成，具体代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>当<code>i</code>小于0时意味着迁移已经结束了，此时先减少迁移线程技术，也就是CAS代码<code>U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)</code>完成的功能。通过确认是否是最后一个退出迁移的线程，也就是代码<code>if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</code>完成的功能，来执行最后一次的检查，也就是将<code>i</code>设置为数组长度值<code>n</code>。再执行一次总体循环，检查每一个槽位都迁移完毕。</p>
<p>最后一次确认完毕后，就开始进行退出操作。也就是相关的赋值动作，这部分简单，不展开说明了。</p>
<p>阶段三用于执行迁移槽位，最为复杂，来看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//省略代码，从链表中迁移数据到新数组</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">//省略代码，从红黑树中读取元素放入新数组</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>逐个槽位进行判断，这个是通过外层最大的for循环来执行的。针对每一个槽位，具体情况具体分析。</p>
<ul>
<li>如果槽位为null，则尝试通过CAS将一个标识迁移的特殊节点，<code>ForwardingNode</code>放入槽位。</li>
<li>如果槽位上的节点已经是<code>ForwardingNode</code>，则忽略，寻找下一个槽位。</li>
<li>不是以上两种情况，则对槽位节点加锁。成功后，执行数据迁移，迁移完毕后，将槽位节点设置为<code>ForwardingNode</code>，用以标识迁移完毕。</li>
</ul>
<p>以链表的数据迁移为例进行分析，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>                          runBit  = fh &amp; n;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt; lastRun = f;</span><br><span class="line">        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">            <span class="keyword">if</span> (b != runBit)</span><br><span class="line">            &#123;</span><br><span class="line">                runBit = b;</span><br><span class="line">                lastRun = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (runBit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ln = lastRun;</span><br><span class="line">            hn = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            hn = lastRun;</span><br><span class="line">            ln = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; p = f; p != lastRun; p = p.next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ph = p.hash;</span><br><span class="line">            K   pk = p.key;</span><br><span class="line">            V   pv = p.val;</span><br><span class="line">            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ln = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(ph, pk, pv, ln);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hn = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(ph, pk, pv, hn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setTabAt(nextTab, i, ln);</span><br><span class="line">        setTabAt(nextTab, i + n, hn);</span><br></pre></td></tr></table></figure>

<p>对于数组长度为n，下标在i上的节点而言，执行2倍扩容后，其下标或者仍然为i，或者为i+n。</p>
<p>因此迁移之前首先遍历链表，将链表中的节点分为两个部分：迁移后下标值不一致和迁移后下标值一致，并且以一致的首节点作为分界线，也就是<code>lastRun</code>变量。<code>runBit</code>为0，意味着<code>lastRun</code>和之后的部分，迁移后下标不变；<code>runBit</code>不为0，意味着<code>lastRun</code>和之后的部分，迁移后下标变为i+n。</p>
<p>遍历首节点到<code>lastRun</code>节点之间的部分，计算其迁移后的下标，构建新的<code>node</code>对象，并且形成链表。而后添加到新的数组中</p>
<h2 id="协助扩容"><a href="#协助扩容" class="headerlink" title="协助扩容"></a>协助扩容</h2><p>在执行元素更新操作时，如果槽位上的节点为<code>ForwardingNode</code>，则意味着当前容器正在扩容，则需要进行协助扩容，也就是方法<code>helpTransfer</code>的内容。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                   (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码和<code>addCounter</code>中的扩容判断部分完全一致。</p>
<p>首先仍然是对当前数组长度计算盖戳标记，也就是<code>resizeStamp</code>。其后在while循环中判断是否要进行协助。while条件<code>nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0</code>表明了当前正在进行扩容，需要协助。</p>
<p>来看第一个if判断：</p>
<ul>
<li><code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code>意味着数组长度已经发生变化，扩容可能已经结束，不需要协助。</li>
<li><code>transferIndex &lt;= 0</code>意味着原始数组已经没有可以分配的扩容区域，不需要协助</li>
<li><code>sc == rs + 1 ||  sc == rs + MAX_RESIZERS</code>这个条件永远不会达成，属于bug。具体可以看<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427" target="_blank" rel="noopener">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427</a></li>
</ul>
<p>如果确认需要协助，就来到第二个if。通过CAS的方式，增加了一个协助线程数量，然后执行迁移方法。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历的实现难度主要是在于遍历的过程中元素可能会新增或者删除，或者遇到扩容的情况。分情况分析：</p>
<ul>
<li>遍历时容器没有变化</li>
<li>遍历时容器元素有新增或者删除</li>
<li>遍历时容器正在扩容</li>
</ul>
<p>遍历是通过生成迭代器方式进行,主要三个方法<code>keySet</code>,<code>valueSet</code>,<code>entrySet</code>。但是遍历的机制都是相同的，具体的实现都是依赖<code>java.util.concurrent.ConcurrentHashMap.Traverser</code>实现的迭代器。</p>
<p>首先来看下该类的重要属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab;<span class="comment">//当前迭代器需要遍历的数组</span></span><br><span class="line">Node&lt;K,V&gt; next; <span class="comment">//迭代器next方法将要返回的值</span></span><br><span class="line">TableStack&lt;K,V&gt; stack, spare; <span class="comment">// 在遍历过程中遇到ForwardingNodes节点时，存储当前遍历信息的对象</span></span><br><span class="line"><span class="keyword">int</span> index; <span class="comment">//下一个要遍历的槽位的下标</span></span><br><span class="line"><span class="keyword">int</span> baseIndex; <span class="comment">//初始槽位数组的当前遍历下标</span></span><br><span class="line"><span class="keyword">int</span> baseLimit;  <span class="comment">//初始槽位数组的遍历下标的终值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> baseSize; <span class="comment">//初始遍历数组的大小</span></span><br></pre></td></tr></table></figure>

<p>从迭代器的<code>tab</code>属性可以推测出迭代的取值是从<code>tab</code>中来定位对应的槽位的。而从<code>baseLimit</code>属性则可以推测出遍历的是从下标0开始的。而<code>baseSize</code>是初始数组的大小且为final，意味着遍历的范围只针对初始数组。结合以上三点，可以得到遍历的第一个原则.</p>
<blockquote>
<p>遍历是以迭代器初始化入参的数组为依据，从下标0开始，遍历到baseLimit截止。</p>
</blockquote>
<p>关于迭代器的可见性，在遍历的时候，容器元素可能添加或者是删除，对于在遍历下标之前的槽位，元素的添加或者删除是不可见的，也不关心。而在遍历下标之后的槽位上的元素新增删除，在遍历到具体的槽位时即可发现。对槽位的读取，上面介绍过，采用的是volatile的方式，因此都可以看到最新的数据。</p>
<p>最复杂的情况要属在遍历的时候遇到容器扩容的情况。迭代器的最基本保证就是不能遍历到重复的元素。但是容器的扩容的时候，下标i的节点会被重新分配到<code>i</code>和<code>i+n（原数组长度）</code>的位置。也就是<code>i+n-1</code>位置上会有部分原本数组上<code>i-1</code>的元素，如果遍历到这个槽位，则会导致重复的元素在遍历中出现。</p>
<p>这边以图的形式更容易来说明，首先见下图</p>
<p><img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191029144409.png" alt=""></p>
<p>下标0-3均已遍历过，在遍历下标4的槽位时发现了该节点是一个<code>ForwardingNode</code>节点，这意味着该数组上剩余的槽位上的节点均已迁移到新的数组中。两个数组中相同颜色的槽位意味着存在节点的迁移关系。比如槽位4上的节点就会迁移到新数组的槽位4和槽位12中。而灰色的部分意味着存在着已经遍历过的槽位。显然，从新数组的下标4开始遍历，一旦遍历到8-11槽位，就会遍历到重复的数据，这显然是不允许的。</p>
<p><code>ConcurrentHashMap</code>的做法就是仍然遍历原始数组，但是发现槽位节点是<code>ForwardingNode</code>，则遍历<code>ForwardingNode</code>节点指向的数组，并且只遍历其<code>i</code>和<code>i+n</code>槽位的数据。然后回归原始数组，继续这个流程。这样的做法，就能避免遍历到新数组中可能存在重复数据的槽位。当然，同时也忽略了这些槽位上新增的数据，但是至少保证了数据的正确性。</p>
<p>知道了算法思路，再来看代码就好理解多了。私以为，这段代码算是最不好理解的部分了（排除红黑树）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = next) != <span class="keyword">null</span>)</span><br><span class="line">                e = e.next;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] t; <span class="keyword">int</span> i, n;  <span class="comment">// must use locals in checks</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> next = e;</span><br><span class="line">                <span class="keyword">if</span> (baseIndex &gt;= baseLimit || (t = tab) == <span class="keyword">null</span> ||</span><br><span class="line">                    (n = t.length) &lt;= (i = index) || i &lt; <span class="number">0</span>)<span class="comment">//标记1</span></span><br><span class="line">                    <span class="keyword">return</span> next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e = tabAt(t, i)) != <span class="keyword">null</span> &amp;&amp; e.hash &lt; <span class="number">0</span>) &#123;<span class="comment">//标记2</span></span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;<span class="comment">//标记3</span></span><br><span class="line">                        e = <span class="keyword">null</span>;</span><br><span class="line">                        pushState(t, i, n);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeBin)</span><br><span class="line">                        e = ((TreeBin&lt;K,V&gt;)e).first;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (stack != <span class="keyword">null</span>)  <span class="comment">//标记4</span></span><br><span class="line">                    recoverState(n);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((index = i + baseSize) &gt;= n)  <span class="comment">//标记5</span></span><br><span class="line">                    index = ++baseIndex; <span class="comment">// visit upper slots if present</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>advance</code>用于确定<code>next</code>方法可以返回的值，也就是确定<code>next</code>属性的值。通过标记1的代码，<code>i = index</code>，可以确定本次需要寻找的槽位，通过标记2的代码<code>e = tabAt(t, i)</code>获取到槽位上的节点。</p>
<p>如果节点是<code>ForwardingNode</code>类型，则意味该槽位和后续的槽位都已经迁移完毕了，因为迁移的时候是从数组的末尾向前开始的。此时将需要遍历的数组切换为本次扩容后的数组，也就是代码<code>tab =((ForwardingNode&lt;K,V&gt;)e).nextTable</code>的含义。切换完成后，保存此时的遍历状态信息，也就是方法<code>pushState</code>的内容，来看下具体的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushState</span><span class="params">(Node&lt;K,V&gt;[] t, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            TableStack&lt;K,V&gt; s = spare;  <span class="comment">// reuse if possible</span></span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">                spare = s.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s = <span class="keyword">new</span> TableStack&lt;K,V&gt;();</span><br><span class="line">            s.tab = t;</span><br><span class="line">            s.length = n;</span><br><span class="line">            s.index = i;</span><br><span class="line">            s.next = stack;</span><br><span class="line">            stack = s;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的内容是通过<code>TableStack</code>形成一个堆栈的数据结构。每次保存遍历状态信息都是一次压栈操作。为了减低GC，提升效率，会将不再使用的<code>TableStack</code>对象以反向的形式连接起来，链表头存储在<code>spare</code>属性。当需要压栈时，可以先尝试从<code>spare</code>获取对象进行复用，而不是马上新建对象。</p>
<p>遍历状态信息保存完毕后，就从扩容后的数组开始遍历。通过标记1和2的代码获取了槽位i上的新的节点。此时就可以针对该槽位进行遍历，不过在遍历之前，需要先确定下一次遍历的下标。也即是标记4的代码内容。来看下方法<code>recoverState</code>。在标记4的调用中，其入参n是传入的扩容后的数组大小。方法代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            TableStack&lt;K,V&gt; s; <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((s = stack) != <span class="keyword">null</span> &amp;&amp; (index += (len = s.length)) &gt;= n) &#123;</span><br><span class="line">                n = len;</span><br><span class="line">                index = s.index;</span><br><span class="line">                tab = s.tab;</span><br><span class="line">                s.tab = <span class="keyword">null</span>;</span><br><span class="line">                TableStack&lt;K,V&gt; next = s.next;</span><br><span class="line">                s.next = spare; <span class="comment">// save for reuse</span></span><br><span class="line">                stack = next;</span><br><span class="line">                spare = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; (index += baseSize) &gt;= n)</span><br><span class="line">                index = ++baseIndex;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在扩容后的数组第一次进入该方法，实际的作用就是将<code>index</code>的值从<code>i</code>增加到<code>i+n</code>。也就是代码<code>index += (len = s.length))&gt;= n</code>的作用。第一次进入的时候，这个表达式为false。第二次进入的时候则为true。那就意味着上次压栈的<code>TableStack</code>保存的旧的数组和遍历下标在新的数组中对应的两个下标位置<code>i</code>和<code>i+n</code>都遍历完毕了。此时进行一个弹栈操作，并且将需要遍历的数组还原为旧的数组，下标和长度信息也还原为压栈时的情况。</p>
<p>一直执行弹栈操作，直到栈空或者再次在某一个扩容数组上index处于有效值,也就是<code>(index += (len = s.length)) &lt; n</code>为真。index是有效值，则遍历该数组该下标的槽位上的节点。如果栈空，则意味着遍历回到了初始数组上，也就是<code>s == null</code>条件成立，此时将index的值加1，也就是<code>index = ++baseIndex</code>，然后继续遍历。</p>
<p>而下一个槽位上的节点，也会是<code>ForwardingNode</code>类型，重复这个流程，直到初始数组遍历完毕。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200207202406.png" alt="风火 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200207202317.jpg" alt="风火 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/29/%E7%90%86%E8%A7%A3OAuth2/" rel="prev" title="理解OAuth2">
      <i class="fa fa-chevron-left"></i> 理解OAuth2
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/30/%E4%BB%8E2-3-4%E6%A0%91%E6%A8%A1%E5%9E%8B%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0/" rel="next" title="从2-3-4树模型到红黑树实现">
      从2-3-4树模型到红黑树实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ConcurrentHashMap源码走读"><span class="nav-number">1.</span> <span class="nav-text">ConcurrentHashMap源码走读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#放入数据"><span class="nav-number">1.2.</span> <span class="nav-text">放入数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器元素总数更新"><span class="nav-number">1.3.</span> <span class="nav-text">容器元素总数更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器扩容"><span class="nav-number">1.4.</span> <span class="nav-text">容器扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协助扩容"><span class="nav-number">1.5.</span> <span class="nav-text">协助扩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历"><span class="nav-number">1.6.</span> <span class="nav-text">遍历</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="风火"
      src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200207124809.jpg">
  <p class="site-author-name" itemprop="name">风火</p>
  <div class="site-description" itemprop="description">博思软件技术架构部技术经理，福建省省级标准《双离线场景二维码标准》撰写人，多年大型项目研发经验。GitChat认证作者，关注团队效率，高并发等方面</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/kuangzhanshatian" title="csdn → https:&#x2F;&#x2F;blog.csdn.net&#x2F;kuangzhanshatian" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>csdn</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.im/user/5d9038d7f265da5bae608146" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5d9038d7f265da5bae608146" rel="noopener" target="_blank"><i class="fa fa-fw fa-juejin"></i>掘金</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/lin-bin-82-12/posts" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;lin-bin-82-12&#x2F;posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/jfire/" title="博客园 → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jfire&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-bokeyuan"></i>博客园</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风火</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
