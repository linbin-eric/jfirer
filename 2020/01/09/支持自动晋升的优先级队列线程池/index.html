<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://jfirer.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="支持优先级内部晋升的无锁并发优先级线程池[TOC] 引言在技术群讨论到一个有意思的业务需求，可以描述为：  有一个内部按照优先级进行任务排序的线程池。线程池会优先执行高优先级的任务。随着时间的流逝，线程池内部低优先级的任务的优先级会逐渐晋升变为高优先级，以避免被不断新增的高优先级任务阻塞导致饿死。  考虑到 JDK 已经为开发者提供了自定义线程池ThreadPoolExecutor以及优先级队列P">
<meta property="og:type" content="article">
<meta property="og:title" content="支持优先级内部晋升的无锁并发优先级线程池">
<meta property="og:url" content="http://jfirer.com/2020/01/09/%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E6%99%8B%E5%8D%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.html">
<meta property="og:site_name" content="风火说">
<meta property="og:description" content="支持优先级内部晋升的无锁并发优先级线程池[TOC] 引言在技术群讨论到一个有意思的业务需求，可以描述为：  有一个内部按照优先级进行任务排序的线程池。线程池会优先执行高优先级的任务。随着时间的流逝，线程池内部低优先级的任务的优先级会逐渐晋升变为高优先级，以避免被不断新增的高优先级任务阻塞导致饿死。  考虑到 JDK 已经为开发者提供了自定义线程池ThreadPoolExecutor以及优先级队列P">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png">
<meta property="og:image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200110163001.png">
<meta property="og:image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200110174426.png">
<meta property="og:image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200110195115.png">
<meta property="og:image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200110195309.png">
<meta property="article:published_time" content="2020-01-09T00:00:00.000Z">
<meta property="article:modified_time" content="2020-02-07T06:49:31.434Z">
<meta property="article:author" content="风火">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png">

<link rel="canonical" href="http://jfirer.com/2020/01/09/%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E6%99%8B%E5%8D%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%BA%BF%E7%A8%8B%E6%B1%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>支持优先级内部晋升的无锁并发优先级线程池 | 风火说</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风火说</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jfirer.com/2020/01/09/%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E6%99%8B%E5%8D%87%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200207124809.jpg">
      <meta itemprop="name" content="风火">
      <meta itemprop="description" content="技术经理，省级标准撰写人，GitChat认证作者。喜欢研究技术。<br/>欢迎加入技术交流群186233599讨论交流。<br/>也欢迎关注笔者公众号：风火说。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风火说">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          支持优先级内部晋升的无锁并发优先级线程池
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-09 08:00:00" itemprop="dateCreated datePublished" datetime="2020-01-09T08:00:00+08:00">2020-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-07 14:49:31" itemprop="dateModified" datetime="2020-02-07T14:49:31+08:00">2020-02-07</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="支持优先级内部晋升的无锁并发优先级线程池"><a href="#支持优先级内部晋升的无锁并发优先级线程池" class="headerlink" title="支持优先级内部晋升的无锁并发优先级线程池"></a>支持优先级内部晋升的无锁并发优先级线程池</h1><p>[TOC]</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在技术群讨论到一个有意思的业务需求，可以描述为：</p>
<blockquote>
<p>有一个内部按照优先级进行任务排序的线程池。线程池会优先执行高优先级的任务。随着时间的流逝，线程池内部低优先级的任务的优先级会逐渐晋升变为高优先级，以避免被不断新增的高优先级任务阻塞导致饿死。</p>
</blockquote>
<p>考虑到 JDK 已经为开发者提供了自定义线程池<code>ThreadPoolExecutor</code>以及优先级队列<code>PriorityBlockingQueue</code>，两者相结合并且定期调整队列中低优先级任务的优先级再进行<code>resort</code>将低优先级的任务调整到队列的前头，也可以一定程度上避免被饿死。</p>
<p>这种方案的问题在于<code>resort</code>的消耗比较高，并且还需要重新计算每一个任务的优先级。为此，引出我们下面的设计，希望使用无锁并发的数据结构存储任务，并且任务支持自动的优先级晋升，保证低优先级的任务最终能够执行而不会被不断增加的高优先级任务饿死。</p>
<p>欢迎加入技术交流群186233599讨论交流，也欢迎关注笔者公众号：风火说。</p>
<a id="more"></a>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><h3 id="如何实现优先级晋升"><a href="#如何实现优先级晋升" class="headerlink" title="如何实现优先级晋升"></a>如何实现优先级晋升</h3><p>声明一个数组，按照循环队列的方式使用。每一个数组槽位上都挂载一个任务列表。有一个当前指针指向数组中的某一个槽位，该槽位即为当前最高优先级任务插入的槽位。指针数字递增方向优先级依次降低。指针以某种方式沿递增方向移动，因为指针指向的槽位代表最高优先级，因此指针的移动实际上意味着所有槽位的优先级都晋升了。</p>
<p>那么这里的优先级只能是离散化的整型数字，并且优先级的范围为 0 到 数组长度减 1 。最高优先级为0。</p>
<p>用图形化的方式表达就是如下的情况</p>
<p><img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt=""></p>
<blockquote>
<p>图中优先级的范围是[0,6]，current指针指向的槽位即为最高优先级，current左侧槽位为最低优先级，current右侧槽位为次高优先级。每一个槽位上都挂载一个队列，队列中的任务的优先级都相同（后续算法中可以看到会有不同的优先级混合）。</p>
<p>每次取任务时总是从current指针指向的槽位的队列读取任务。当一定时间流逝后，current指针沿着右侧移动一位，此时意味着所有槽位的优先级都被晋升了，除了原本的current指向的槽位，它变为了最低优先级槽位。</p>
<p>由于current指针总是在移动，因此最终会移动到之前低优先级的槽位，此时该槽位下的任务就成了最高优先级任务，被读取执行。这样就避免了在运行过程不断有高优先级任务被加入导致原本的低优先级饿死的情况发生。</p>
</blockquote>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><p>根据上面的优先级晋升思路，显然应该有一个数组，其不同的槽位代表着不同的优先级。每一个槽位上挂载一个 MPMC 类型的队列，用于该优先级下任务的添加和读取。</p>
<p>使用一个当前指针，该指针指向的槽位为最高优先级槽位。</p>
<h3 id="一个指针产生的问题"><a href="#一个指针产生的问题" class="headerlink" title="一个指针产生的问题"></a>一个指针产生的问题</h3><p>如果只有一个指针，意味着读取任务时，从该指针指向的槽位读取，因此此时指针指向的槽位是最高优先级。而插入任务的时候，需要根据当前指针进行计算。这种模式在优先级晋升时存在并发问题。</p>
<p>当指针从槽位1指向更新到槽位2。此时槽位1可能还存在部分剩余的任务，这部分任务的实际优先级应该是高于槽位2当中的。而如果在这个时候插入最低优先级的任务，可能就会插入到槽位1中。那么槽位1的任务队列实际就混合了最高优先级和最低优先级的任务，无法区分。</p>
<p>为了解决不同优先级任务在同一个队列中混合的问题，我们可以在指针移动时，将之前槽位的剩余移动到当前槽位的队列头。这实际上就意味着要求队列是出于双端队列模式。但是因为指针移动和任务移动无法原子化进行，还是会造成槽位1的队列中最高优先级任务和最低优先级任务混在一起的情况。</p>
<p>从实现效果而言，我们需要的是在指针移动的时候，保证槽位1中剩余的原本高优先级的任务执行完毕后才能去执行槽位2这个“原本的次高优先级，现在的最高优先级“的任务。从效果来看，并不需要一定移动任务，可以通过一种手段，保证槽位1中原本高优先级任务执行完毕后再去执行槽位2的任务即可。</p>
<p>基于这种考量，我们将一个指针拆分为两个：任务插入指针和任务读取指针。</p>
<h3 id="任务插入指针和任务读取指针"><a href="#任务插入指针和任务读取指针" class="headerlink" title="任务插入指针和任务读取指针"></a>任务插入指针和任务读取指针</h3><p>基于并发读写的考虑，两个指针都是<code>AtomicInteger</code>类型。两个指针的作用分别为：</p>
<ul>
<li>任务插入指针：该指针指向的槽位为<strong>当前</strong>最高优先级槽位（后续会引入轮次这个概念，因此这里对当前加粗）。</li>
<li>任务读取指针：从结构体中获取任务时使用该指针指向的槽位上获取任务队列进行任务读取。</li>
</ul>
<p>任务插入指针和任务读取指针分离的好处在于，任务插入指针的移动意味着不同槽位优先级的实际晋升。而读取可以依照读取指针指向的槽位上的队列读取任务，直到对应优先级的任务读取完毕后再移动读取指针到下一个槽位。这样一来，保证了按照入列的顺序被公平的处理，也保证了同一个时间单位高优先级的任务优于低优先级任务被处理，也避免了单一指针移动需要的任务拷贝带来的不同优先级任务污染问题。</p>
<h3 id="任务插入指针如何移动"><a href="#任务插入指针如何移动" class="headerlink" title="任务插入指针如何移动"></a>任务插入指针如何移动</h3><p>插入指针可以按照两种策略移动：</p>
<ul>
<li>自然时间流逝移动，一定时间后移动。</li>
<li>以读取次数为单位，一定次数后移动。</li>
</ul>
<p>如果选择策略一，需要后台配置一个线程，按照固定时间移动插入指针；如果选择策略二，需要一个全局的<code>AtomicInteger</code>对象，用于次数判定。</p>
<p>如果选择方案一，可能会存在一种场景，往线程池中投入了大量的同一个优先级的任务，使得某个槽位上的队列长度很长。如果任务处理相对缓存，则任务插入指针可能会被移动多次。这种移动会使得槽位上队列有了很多不同优先级的任务。而读取任务时按照优先级逐步去处理，这使得产生了这么多不同的优先级实际上意义是不大的。</p>
<p>因此采用策略二会更加合适一些。</p>
<p>由于读取任务时是多线程的，因此策略二实现上需要注意的点包括：</p>
<ul>
<li><code>AtomicInteger#incrementAndGet</code>实现任务读取次数累加。如果返回的数字是阈值的倍数，则意味着可以移动任务插入指针。</li>
<li>使用<code>AtomicInteger#incrementAndGet</code>来移动插入指针。</li>
</ul>
<p>在这里对插入指针移动的并发考量在于，由于读取线程对读取计数使用<code>AtomicInteger#incrementAndGet</code>方式累加是必然成功，而返回数值是晋升阈值的倍数时必然需要实现插入指针的递增。因为递增的必然性，因此同样使用<code>AtomicInteger#incrementAndGet</code>方式来实现。</p>
<h3 id="任务插入指针移动到同一位置导致的优先级任务混合问题"><a href="#任务插入指针移动到同一位置导致的优先级任务混合问题" class="headerlink" title="任务插入指针移动到同一位置导致的优先级任务混合问题"></a>任务插入指针移动到同一位置导致的优先级任务混合问题</h3><p>假定系统初始状态，插入和读取指针都指向了槽位1，在槽位1上插入了大量的任务。随着任务的读取，插入指针移动到了槽位2，此时该槽位上插入了一些任务。随着任务的读取，插入指针继续移动，移动过数组的长度后，再次指向了槽位2。假定此时读取指针仍然在槽位1，而如果这个时候插入插入任务。那么实际上槽位2队列中任务应该分为两种：<strong>前半部分是上一个轮次插入的任务，后半部分是当前刚插入的任务</strong>。</p>
<p>如果读取指针移动到槽位2，应该将前半部分任务执行完毕后就去执行槽位3上的任务，而不是将所有的任务都执行完。因此槽位3上的任务实际优先级应该高于槽位2队列中后半部分的任务。</p>
<p>基于上述情况，问题可以转化为<strong>依靠读取指针在读取任务时，如何识别当前队列中不是本轮次要处理的任务进而移动读取指针？</strong></p>
<p>考虑到任务插入指针和任务读取指针本身是有值的，这个值单调递增，实际上可以看成是一种“顺序”概念的表达。因此任务的准备添加时，可以将插入指针的值加上任务的优先级，声明为任务的插入优先级。读取指针在读取任务时，只有当前任务的插入优先级等于读取指针的值，意味着该任务时本轮次读取指针应该要处理的任务。如果读取的任务的插入优先级与读取指针不等时，意味着当前队列不能再读取任务，应该移动读取指针。</p>
<p>通过任务本身的插入优先级避免了不同轮次的任务在一个队列中被混合导致的优先级混乱。</p>
<h3 id="任务读取指针如何移动"><a href="#任务读取指针如何移动" class="headerlink" title="任务读取指针如何移动"></a>任务读取指针如何移动</h3><p>上个章节提出任务的插入优先级，解决了不同轮次的任务在同一个队列可能会混合的问题。这个问题的解决引出了读取指针的移动策略：在读取到的任务的插入优先级与读取指针的值不等时意味着需要移动。</p>
<p>但是这里又产生了新的问题：并发移动读取指针的问题。在读取并发的情况下，会遇到一个问题：读取出来的任务的优先级不符合指针，此时要重新放回队列，但是重新放入，就可能和任务的插入混合，造成数据混乱。</p>
<p>有几种可能的解决方式：</p>
<ul>
<li>任务的读取采用<code>Sync</code>关键字修饰，如果读取任务不符合，则放回，并且移动指针。由于没有读取并发，但仍然可能因为读取的放回和新任务的添加造成数据混乱。</li>
<li>采用分段机制，每一个分段是一个队列，分段和分段构成一个队列。一个分段内的优先级是固定的，因此当分段耗尽时，就是切换读取指针的时候。</li>
</ul>
<p>策略一并不能彻底解决问题，在这里我们采用策略二的方案。</p>
<p>策略二的引入实际上改变了上面的一个数据结构，也即是数组存储的元素不再是一个任务队列，而是一个分段队列。而每一个分段内部又存储了任务队列，并且分段的队列的任务的插入优先级均是相同的。这意味着分段在创建的时候就具备了插入优先级这个值。分段和分段的插入优先级必然不同，这个结构就天然的支持了轮次的概念。</p>
<p>分段结构的引入导致了数据结构的变化，这实际上会改变任务插入和任务读取的流程。下文会再来细说具体的实现。分析到这里，读取指针的移动时机就很明白了，在分段内数据耗尽，就意味着某个具体插入优先级的任务都被读取完毕了。</p>
<p>当然，考虑到读写并发的原因，读取线程发现分段内数据耗尽并不意味着该插入优先级的任务全被读取了，后文会针对并发场景在处理流程上解决。</p>
<h3 id="插入和读取并发"><a href="#插入和读取并发" class="headerlink" title="插入和读取并发"></a>插入和读取并发</h3><p>插入和读取可能在同一个槽位同一个分段上并发。分段的队列本身是支持MPMC的，这并没有问题。</p>
<blockquote>
<p>可能会出现一种并发异常就是插入线程读取了插入指针的值，并且准备插入数据，但是因为线程调度的原因，失去了CPU资源，尚未完成数据插入。此时读取线程将槽位内的任务读取完毕后认为没有数据，则移动了读取指针到下一个槽位。在读取指针移动后，插入线程才完成数据的插入。这样导致本来应该是高优先级的任务变成最低优先级槽位上的任务。而当下一轮次读取指针再次指向该槽位时，读取指针获取的到任务的任务优先级又会和读取指针本身的数值冲突。</p>
</blockquote>
<p>针对并发的异常场景，有一种常见的解决思路就是二次检查。也就是读取线程在移动任务读取指针后，再次检查下当前分段内是否出现了新的任务，如果有，则协助迁移到下一个槽位上；写入线程在放入任务后，检查是否读取指针移动过，如果有，则协助迁移到下一个槽位上。</p>
<p>然而，读取线程检查分段内的队列是否剩余，写入线程检查读取指针是否移动，这些状态都是在动态变化的，仍然会产生一些其他问题。双重检查一般会引入一个终止状态来来减少可能的变化场景。在这里，我们为分段引入状态：使用中和终止。一个分段初始化时是使用中状态，当读取线程认为该分段内的任务都被消耗后，则应该更新为终止状态。一旦分段进入终止状态，则被抛弃，不应该再有任务数据添加到该分段中。</p>
<p>通过分段状态，我们可以将任务区分为终止前添加到分段和终止后添加到分段两类。前者需要被正常读取，后者则需要迁移到其它合适的分段中再被处理。</p>
<p>到这里为止，我们针对数据结构和其元素属性的变化就完成了。</p>
<p>将数组通过循环队列的方式来表达不同的优先级。通过任务写指针的移动来实现内部任务优先级的晋升。通过读指针来实现任务严格按照优先级顺序被处理，且避免低优先级任务被高优先级任务饿死。数组的元素指向一个该槽位上插入优先级最低的分段。一同散列到同一个槽位上的分段按照插入优先级的顺序形成队列。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>整个代码当中，最为复杂的就是任务的插入和读取，下面分别来设计流程。</p>
<h3 id="任务插入"><a href="#任务插入" class="headerlink" title="任务插入"></a>任务插入</h3><p>上面推导过程分析了插入和读取并发可能导致的冲突场景。这里我们细化其解决流程。对于插入线程而言，要处理的情况包括有：</p>
<ul>
<li>元素对应槽位上没有分段。</li>
<li>元素对应槽位上的分段的插入优先级和插入指针的值不相等。</li>
<li>元素对应槽位上分段列表中插入优先级与插入指针相符的分段处于终止状态</li>
<li>元素对应槽位上的分段插入优先级与插入指针相等，且处于使用状态。</li>
</ul>
<p>可以看到，只有第四种情况任务可以在当前分段插入成功，且插入完毕后还需要再次检查分段的状态。基于这些考量，我们将插入流程设计为</p>
<p><img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200110163001.png" alt=""></p>
<p>可以看到，这个流程中没有处理槽位上没有分段的情况，这个在下一个章节我们会分析。</p>
<h3 id="任务的读取"><a href="#任务的读取" class="headerlink" title="任务的读取"></a>任务的读取</h3><p>有了分段的存在，读取指针的移动判定更加复杂，读取线程可能碰到的场景有：</p>
<ul>
<li>读取指针散列的槽位上没有分段。</li>
<li>读取指针散列的槽位上有分段且状态为使用，分段内没有任务。</li>
<li>读取指针散列的槽位上有分段且状态为使用，分段内有任务。</li>
<li>读取指针散列的槽位上有分段且状态为关闭，分段内没有任务。</li>
<li>读取指针散列的槽位上有分段且状态为关闭，分段内有任务。</li>
</ul>
<p>只有第三种情况可以读取任务并且进行处理。有了轮次这个概念，读取指针永远只会读取槽位上的第一个分段。如果槽位上没有分段，或者分段的插入优先级与读取指针不同，或者分段内没有任务，则可以考虑移动读取指针。<strong>注意</strong>，分段状态为关闭并不是读取指针移动的条件，原因下面会分析。</p>
<p>但是移动读取指针的时候首先需要考虑当前读取指针是否已经处于（写入指针的值+最低优先级数字），如果是的话，意味着已经处于边界，不应该在移动。</p>
<p>分段状态的更新只能由读取线程来进行。当读取线程发现该分段已经没有任务了，首先应该通过CAS的方式更新分段状态。CAS竞争成功的线程再次检查分段内是否出现了新的任务，如果出现的话，则提取任务，完成任务读取。<strong>为何不将任务移动到下一个槽位</strong>。因为下一个槽位上可能还没有分段，此时读取线程可能和写入线程竞争槽位上的分段写入。如果写入线程竞争成功，读取线程移动过去的任务数据的优先级就放到了错误的分段中；如果读取线程竞争成功，则读取线程创建的分段必须是第一个分段，否则任务还是移动到错误的地方。</p>
<p>解决这个问题最好的办法就是不解决。不移动任务，仍然在该分段上读取任务直到任务耗尽。然后再尝试移动读取指针。而对于写入线程而言，当其发现分段的状态变为终止后，是提取出任务重新执行完整的放入流程，不会有并发的问题。</p>
<p>再次梳理下没有任务情况下的流程，应该是通过CAS修改分段的状态。无论成功或失败，都可以继续检查队列是否有任务，如果有的话，则返回读取到的任务。如果没有的话，则CAS将读取指针+1。竞争成功的线程将当前分段的下一个分段设置给槽位，并且重新执行读取流程。竞争失败的线程则反复检查读取指针的值，发现变化后，重新执行读取流程。</p>
<p>这里有一个并发冲突需要考虑，当读取线程尝试将当前分段的下一个分段设置为槽位的值时，可能此时当前分段的下一个分段是null，而写入线程正在尝试为当前分段设置下一个分段。这种情况下可能导致下一个分段丢失。特别的，如果当前分段的下一个分段已经被设置，并且有任务被放入其中，丢失这个分段就意味着数据丢失。</p>
<p>为了避免这个情况，在当前分段的下一个分段为null时，就不能将下一个分段（属性值）设置给槽位。这使得在读取到分段时，需要首先检查分段的优先级，确认是否本轮次。如果是的话，再执行后续的流程。否则要么移动（该分段没有下一个分段），要么将该分段的下一个分段设置给槽位后，在移动。</p>
<p>从这个角度出发，我们可以在初始化的时候，将数组中的元素都填充一个分段。这样写入线程就不需要处理槽位上可能为空的场景了。</p>
<p>基于此，我们将读取任务的变化为：</p>
<ul>
<li>槽位上的分段优先级小于读取指针，且分段状态为终止。</li>
<li>槽位上的分段优先级等于读取指针。</li>
<li>槽位上的分段优先级大于读取指针。</li>
</ul>
<p>第一种情况，如果该分段有下一个分段，CAS更新到槽位上；如果没有，则CAS移动读取指针。</p>
<p>第二种情况，按照上面分析的流程进行处理即可。</p>
<p>第三种情况，CAS移动读取指针。</p>
<p>综上，我们可以将读取流程设计为</p>
<p><img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200110174426.png" alt=""></p>
<h2 id="包装为BlockQueue"><a href="#包装为BlockQueue" class="headerlink" title="包装为BlockQueue"></a>包装为BlockQueue</h2><p>在JDK提供的<code>ThreadPoolExecutor</code>类的构造方法中，需要传入<code>BlockingQueue</code>作为队列的接口。显然，上述的存储结构并不能支持<code>BlockQueue</code>,需要考虑包装。</p>
<p>显然，上面的存储结果在写入的时候并不会阻塞，因此只需要考虑如何包装读取数据不存在时的阻塞等待即可。</p>
<p>简单的方式就是在读取失败的获取锁，并且在队列空的<code>condition</code>对象执行等待；插入任务的时候执行唤醒。</p>
<h2 id="效果展现"><a href="#效果展现" class="headerlink" title="效果展现"></a>效果展现</h2><p>测试代码如下</p>
<p><img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200110195115.png" alt=""></p>
<p>首先添加一定量的高优先级任务，随后添加5个低优先级，最后通过<code>CountLatch</code>模拟在运行过程中添加高优先级任务。</p>
<p>如果单纯按照优先级排序，则需要所有高优先级任务输出完毕后才会输出低优先级任务，显然这是错误的。正确的实现应该是先输出第一批高优先级任务，再输出低优先级任务，最后输出第三批高优先级任务。运行代码，看到结果如下</p>
<p><img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200110195309.png" alt=""></p>
<p>与我们的预期相吻合。</p>
<h2 id="代码托管地址"><a href="#代码托管地址" class="headerlink" title="代码托管地址"></a>代码托管地址</h2><p>Gitee:<a href="https://gitee.com/eric_ds/eric_article/blob/master/优先级自动晋升线程池/AutoPromotePriorityQueue.java" target="_blank" rel="noopener">https://gitee.com/eric_ds/eric_article/blob/master/优先级自动晋升线程池/AutoPromotePriorityQueue.java</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200207202406.png" alt="风火 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200207202317.jpg" alt="风火 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/24/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9ABASE%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="最终一致性：BASE论文笔记">
      <i class="fa fa-chevron-left"></i> 最终一致性：BASE论文笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/12/%E5%BF%83%E8%B7%B3%E4%B8%8E%E8%B6%85%E6%97%B6%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%97%B6%E9%97%B4%E8%BD%AE%E8%B6%85%E6%97%B6%E5%99%A8/" rel="next" title="心跳与超时：高并发高性能的时间轮超时器">
      心跳与超时：高并发高性能的时间轮超时器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#支持优先级内部晋升的无锁并发优先级线程池"><span class="nav-number">1.</span> <span class="nav-text">支持优先级内部晋升的无锁并发优先级线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#推导过程"><span class="nav-number">1.2.</span> <span class="nav-text">推导过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现优先级晋升"><span class="nav-number">1.2.1.</span> <span class="nav-text">如何实现优先级晋升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构设计"><span class="nav-number">1.2.2.</span> <span class="nav-text">数据结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个指针产生的问题"><span class="nav-number">1.2.3.</span> <span class="nav-text">一个指针产生的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务插入指针和任务读取指针"><span class="nav-number">1.2.4.</span> <span class="nav-text">任务插入指针和任务读取指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务插入指针如何移动"><span class="nav-number">1.2.5.</span> <span class="nav-text">任务插入指针如何移动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务插入指针移动到同一位置导致的优先级任务混合问题"><span class="nav-number">1.2.6.</span> <span class="nav-text">任务插入指针移动到同一位置导致的优先级任务混合问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务读取指针如何移动"><span class="nav-number">1.2.7.</span> <span class="nav-text">任务读取指针如何移动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入和读取并发"><span class="nav-number">1.2.8.</span> <span class="nav-text">插入和读取并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现"><span class="nav-number">1.3.</span> <span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#任务插入"><span class="nav-number">1.3.1.</span> <span class="nav-text">任务插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务的读取"><span class="nav-number">1.3.2.</span> <span class="nav-text">任务的读取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装为BlockQueue"><span class="nav-number">1.4.</span> <span class="nav-text">包装为BlockQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#效果展现"><span class="nav-number">1.5.</span> <span class="nav-text">效果展现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码托管地址"><span class="nav-number">1.6.</span> <span class="nav-text">代码托管地址</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="风火"
      src="https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20200207124809.jpg">
  <p class="site-author-name" itemprop="name">风火</p>
  <div class="site-description" itemprop="description">技术经理，省级标准撰写人，GitChat认证作者。喜欢研究技术。<br/>欢迎加入技术交流群186233599讨论交流。<br/>也欢迎关注笔者公众号：风火说。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/kuangzhanshatian" title="csdn → https:&#x2F;&#x2F;blog.csdn.net&#x2F;kuangzhanshatian" rel="noopener" target="_blank"><i class="fa fa-fw fa-csdn"></i>csdn</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.im/user/5d9038d7f265da5bae608146" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5d9038d7f265da5bae608146" rel="noopener" target="_blank"><i class="fa fa-fw fa-juejin"></i>掘金</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/lin-bin-82-12/posts" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;lin-bin-82-12&#x2F;posts" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/jfire/" title="博客园 → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jfire&#x2F;" rel="noopener" target="_blank"><i class="fa fa-fw fa-bokeyuan"></i>博客园</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风火</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  

</body>
</html>
